/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./js/index.js":
/*!*********************!*\
  !*** ./js/index.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var three_examples_jsm_webxr_VRButton_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three/examples/jsm/webxr/VRButton.js */ \"./node_modules/three/examples/jsm/webxr/VRButton.js\");\n\n\nvar camera, controls, scene, renderer, dolly, gui;\nvar up = 0;\nvar left = 0;\nvar direction = new THREE.Vector3; // controller properties\ndirection.x = 0; direction.y = 0; direction.z = 0;\nvar clock = new THREE.Clock();\nvar lut = new THREE.Lut(\"cooltowarm\", 512); // options are rainbow, cooltowarm and blackbody\nvar floor, stack, grid, inversion_layer\nvar vert_axis, horiz_axis, temp_line, top_temp_line;\nvar particles = new THREE.Group;\nvar world_objects = new THREE.Group;\n\nvar vive = false; // if false, use oculus instead\n// diffusion parameters\nvar params = {\n    'D': 0.01, 'birth_rate': 100., 'u': 1.0,\n    'Dx': true, 'H_stack': 2.0, 'Gamma': 10,\n    'Gamma_inv': -200, 'T_surf': 25, 'T_stack': 0,\n    'H_inversion': 20, 'adiab': true, 'colour_by': 'Relative Temp',\n    'inversion_layer': false, 'cmin': -0.25, 'cmax': 0.25,\n    'turbulence': false, 'I': 0.2, 'omega': 1.0,\n    'wind_type': 'Boundary Layer',\n    // 'wind_type':'Uniform',\n}\nlut.setMin(params.cmin);\nlut.setMax(params.cmax);\n\nvar urlParams = new URLSearchParams(window.location.search);\nif (urlParams.has('VR')) {\n    var VR = true;\n    y_offset = 2; // vertical offset to get camera at right height\n}\nelse {\n    var VR = false;\n    y_offset = 0;\n}\n\nvar root_dir = 'http://localhost:54321/';\nif (window.location.hostname.includes('benjymarks')) {\n    root_dir = 'http://www.benjymarks.com/dispersion-vr/';\n    cache = true;\n}\nelse if (window.location.hostname.includes('github')) {\n    root_dir = 'https://benjym.github.io/dispersion-vr/';\n}\n\nvar fly_speed = 2.; // how fast you can fly in VR\n//        var numParticles = 1;\nvar D = 0.1; // diffusivity\n// var birth_rate = 100.; // how often to add a particle\nvar u = 1.0; // wind velocity\nvar Dx = false; // diffusion in downwind direction\n// stack\nvar R = 0.1; // stack radius\nvar g = 9.81; // acceleration due to gravity\nvar Gamma_dry_adb = 10.0 // deg C / km\nvar N_max = 2000;\nvar X_max = 50;\nvar nR = 1000.; // nR from PV=nRT, sets initial size of particles\nvar positions = new Float32Array(N_max * 3);\nvar T = new Float32Array(N_max);\nvar v_y = new Float32Array(N_max);\n// var H = 5; // height of temperature lines\nconst presets = { 'Presets': ['Looping', 'Coning', 'Fanning', 'Lofting', 'Fumigation', 'Trapping'] };\nvar preset_settings = [ // FIXME - THESE ARE ALL WRONG!!!!\n    { 'Presets': 'Looping', 'u': 0.5, 'H_stack': 10, 'Gamma': 200, 'Gamma_inv': 200, 'T_stack': 0, 'inversion_layer': false, 'turbulence': true }, // strong lapse condition\n    { 'Presets': 'Coning', 'u': 0.5, 'H_stack': 10, 'Gamma': 1, 'Gamma_inv': 0, 'T_stack': 0, 'inversion_layer': false, 'turbulence': false }, // weak lapse condition\n    { 'Presets': 'Fanning', 'u': 0.5, 'H_stack': 10, 'H_inversion': 100, 'Gamma': -200, 'inversion_layer': false, 'T_stack': 0, 'turbulence': false }, // inverse condition\n    { 'Presets': 'Lofting', 'u': 0.5, 'H_stack': 10, 'H_inversion': 9.5, 'Gamma': -500, 'Gamma_inv': 100, 'T_stack': 0, 'inversion_layer': true, 'turbulence': false }, // inverse below, lapse aloft\n    { 'Presets': 'Fumigation', 'u': 0.5, 'H_stack': 10, 'H_inversion': 10.5, 'Gamma': 200, 'Gamma_inv': -200, 'T_stack': 0, 'inversion_layer': true, 'turbulence': false }, // lapse below, inversion aloft\n    { 'Presets': 'Trapping', 'u': 0.5, 'H_stack': 10, 'H_inversion': 10.5, 'Gamma': 1, 'Gamma_inv': -100, 'T_stack': 0, 'inversion_layer': true, 'turbulence': false }, // weak lapse below, inversion aloft\n]\nvar debug_VR = false;\nvar debug_air_flow = false;\nvar colour_options = false;\n\ninit();\nadd_renderer();\nadd_controllers();\nadd_temp_axes();\nif (VR) {\n    gui = dat.GUIVR.create('Parameters');\n    add_gui();\n    gui.position.x = 2;\n    gui.position.z = -2;\n    gui.rotation.y = -Math.PI / 2.;\n    gui.position.y = 2;\n    scene.add(gui);\n}\nelse {\n    gui = new dat.GUI({ width: 500 });\n    add_gui();\n}\nadd_particles();\nanimate();\nif (debug_VR) {\n    add_left_oculus_model(stack);\n    add_right_oculus_model(vert_cone);\n}\n\nfunction rotateAboutPoint(obj, point, axis, theta, pointIsWorld) {\n    // obj - your object (THREE.Object3D or derived)\n    // point - the point of rotation (THREE.Vector3)\n    // axis - the axis of rotation (normalized THREE.Vector3)\n    // theta - radian value of rotation\n    // pointIsWorld - boolean indicating the point is in world coordinates (default = false)\n    pointIsWorld = (pointIsWorld === undefined) ? false : pointIsWorld;\n    if (pointIsWorld) { obj.parent.localToWorld(obj.position); } // compensate for world coordinate\n    obj.position.sub(point); // remove the offset\n    obj.position.applyAxisAngle(axis, theta); // rotate the POSITION\n    obj.position.add(point); // re-add the offset\n    if (pointIsWorld) { obj.parent.worldToLocal(obj.position); }// undo world coordinates compensation\n    obj.rotateOnAxis(axis, theta); // rotate the OBJECT\n}\n\nfunction add_temp_axes() {\n\n    var H = params.H_stack + 20;\n    var geometry = new THREE.CylinderGeometry(0.1, 0.1, 1, 32);\n    var material = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });\n    vert_axis = new THREE.Mesh(geometry, material);\n    vert_axis.scale.y = 3.;\n    vert_axis.position.y = 3. / 2. - params.H_stack;\n    vert_axis.position.z = -2.;\n    world_objects.add(vert_axis);\n\n    temp_scale = 5.; // m/deg C\n    horiz_axis = new THREE.Mesh(geometry, material);\n    horiz_axis.scale.y = params.T_surf / temp_scale;\n    horiz_axis.position.y = -params.H_stack;\n    horiz_axis.position.z = -2. - params.T_surf / temp_scale / 2.;\n    horiz_axis.rotation.x = Math.PI / 2;\n    world_objects.add(horiz_axis);\n\n    temp_line = new THREE.Mesh(geometry, material);\n    temp_line.scale.y = H;\n    // temp_line.position.y = H/2.-params.H_stack;\n    // temp_line.position.z = -2. - params.T_surf/temp_scale;\n    world_objects.add(temp_line);\n\n    top_temp_line = new THREE.Mesh(geometry, material);\n    top_temp_line.scale.y = H;\n    top_temp_line.position.y = H / 2. - params.H_stack;\n    top_temp_line.position.z = -2. - params.T_surf / temp_scale;\n    world_objects.add(top_temp_line);\n    top_temp_line.visible = params.inversion_layer;\n\n    var geometry = new THREE.CylinderGeometry(0.05, 0.05, 1, 32);\n    var material = new THREE.MeshStandardMaterial({ color: 0xFF0000 });\n    adiab_line = new THREE.Mesh(geometry, material);\n    adiab_line.scale.y = H;\n    adiab_line.position.y = H / 2. - params.H_stack;\n    adiab_line.position.z = -2. - params.T_surf / temp_scale;\n    world_objects.add(adiab_line);\n    var rot_angle = Math.atan(Gamma_dry_adb / 1000.);\n    rotateAboutPoint(adiab_line, new THREE.Vector3(0, -2, -2 - params.T_surf / temp_scale), new THREE.Vector3(1, 0, 0), rot_angle, false);\n\n    var geometry = new THREE.CylinderGeometry(0., 0.2, 1, 32);\n    var material = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });\n    vert_cone = new THREE.Mesh(geometry, material);\n    vert_cone.scale.y = 0.2;\n    vert_cone.position.y = 2.5 - params.H_stack;\n    vert_axis.add(vert_cone);\n\n    var geometry = new THREE.CylinderGeometry(0.2, 0., 1, 32);\n    var material = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });\n    horiz_cone = new THREE.Mesh(geometry, material);\n    horiz_cone.scale.y = 0.2;\n    // horiz_cone.position.y = 2.5-params.H_stack;\n    // horiz_cone.rotation.x = Math.PI/2;\n    horiz_cone.position.y = - params.T_surf / temp_scale / 8.;\n    horiz_axis.add(horiz_cone);\n\n    var font_loader = new THREE.FontLoader();\n    font_loader.load('https://threejs.org/examples/fonts/helvetiker_bold.typeface.json', function (font) {\n        // font_loader.load( root_dir + 'node_modules/three/examples/fonts/helvetiker_bold.typeface.json', function ( font ) {\n        var fontsize = 0.25;\n        var geometry = new THREE.TextBufferGeometry(\"Temperature\", { font: font, size: fontsize, height: fontsize / 5. });\n        var material = new THREE.MeshStandardMaterial({ color: 0xdddddd });\n        var temp_label = new THREE.Mesh(geometry, material);\n        temp_label.rotation.x = -Math.PI / 2.;\n        temp_label.rotation.y = Math.PI / 2.;\n        temp_label.position.z = -0.3;\n        temp_label.position.y = 4.0;\n        horiz_cone.add(temp_label);\n\n        var geometry = new THREE.TextBufferGeometry(\"Environmental lapse\", { font: font, size: fontsize, height: fontsize / 5. });\n        var material = new THREE.MeshStandardMaterial({ color: 0xdddddd });\n        var curr_label = new THREE.Mesh(geometry, material);\n        curr_label.rotation.x = -Math.PI / 2.;\n        curr_label.rotation.z = Math.PI / 2.;\n        curr_label.position.x = -0.4;\n        curr_label.position.z = -2.0;\n        curr_label.position.y = 0.6;\n        horiz_cone.add(curr_label);\n\n        var geometry = new THREE.TextBufferGeometry(\"Altitude\", { font: font, size: fontsize, height: fontsize / 5. });\n        var z_label = new THREE.Mesh(geometry, material);\n        z_label.position.x = -0.3;\n        z_label.position.y = -2.5;\n        z_label.rotation.z = Math.PI / 2.;\n        vert_cone.add(z_label);\n        z_label.scale.x = 2.;\n\n        var geometry = new THREE.TextBufferGeometry(\"Adiabatic lapse\", { font: font, size: fontsize, height: fontsize / 5. });\n        var material = new THREE.MeshStandardMaterial({ color: 0xFF0000 });\n        var ALR_label = new THREE.Mesh(geometry, material);\n        ALR_label.rotation.x = -Math.PI / 2.;\n        ALR_label.rotation.z = Math.PI / 2.;\n        ALR_label.position.x = 0.8;\n        ALR_label.position.z = -2.0;\n        ALR_label.position.y = 0.6;\n        horiz_cone.add(ALR_label);\n\n    });\n\n    reset_temp_line();\n\n}\n\nfunction reset_temp_line() {\n\n    if (params.Gamma > 0) {\n        params.turbulence = true;\n        params.I = 0.2 * params.Gamma / 1000. // FIXME - this is currently garbage\n\n    }\n    else {\n        params.turbulence = false;\n    }\n\n    var H = params.H_stack + 20;\n    // vert_axis.scale.y = H;\n    vert_axis.position.y = 3. / 2. - params.H_stack;\n    horiz_axis.scale.y = params.T_surf / temp_scale;\n    horiz_axis.position.y = -params.H_stack;\n    horiz_axis.position.z = -2. - params.T_surf / temp_scale / 2.;\n\n    top_temp_line.visible = params.inversion_layer;\n    if (params.inversion_layer) {\n        var rot_angle = Math.atan(params.Gamma / 1000. / temp_scale);\n        var L = params.H_inversion / Math.cos(rot_angle);\n        temp_line.position.x = 0;\n        temp_line.scale.y = L;\n        temp_line.position.y = L / 2. - params.H_stack;\n        temp_line.position.z = -2. - params.T_surf / temp_scale;\n        temp_line.rotation.x = 0;\n        rotateAboutPoint(temp_line, new THREE.Vector3(0, -params.H_stack, -2 - params.T_surf / temp_scale), new THREE.Vector3(1, 0, 0), rot_angle, false);\n\n        var rot_angle = Math.atan(params.Gamma_inv / 1000. / temp_scale);\n        var L_top = (H - params.H_inversion) / Math.cos(rot_angle);\n        var T_top = params.T_surf - params.Gamma * params.H_inversion / 1000. // temperature at bottom of inversion layer\n        top_temp_line.position.x = 0;\n        top_temp_line.scale.y = L_top;\n        top_temp_line.position.y = L_top / 2. - params.H_stack + params.H_inversion;\n        top_temp_line.position.z = -2. - T_top / temp_scale;\n        top_temp_line.rotation.x = 0;\n        rotateAboutPoint(top_temp_line, new THREE.Vector3(0, -params.H_stack + params.H_inversion, -2 - T_top / temp_scale), new THREE.Vector3(1, 0, 0), rot_angle, false);\n    }\n    else {\n        temp_line.position.x = 0;\n        temp_line.scale.y = H;\n        temp_line.position.y = H / 2. - params.H_stack;\n        temp_line.position.z = -2. - params.T_surf / temp_scale;\n        temp_line.rotation.x = 0;\n        var rot_angle = Math.atan(params.Gamma / 1000. / temp_scale);\n        rotateAboutPoint(temp_line, new THREE.Vector3(0, -params.H_stack, -2 - params.T_surf / temp_scale), new THREE.Vector3(1, 0, 0), rot_angle, false);\n    }\n\n    adiab_line.position.x = 1;\n    adiab_line.scale.y = H;\n    adiab_line.position.y = H / 2. - params.H_stack;\n    adiab_line.position.z = -2. - params.T_surf / temp_scale;\n    adiab_line.rotation.x = 0;\n    var rot_angle = Math.atan(Gamma_dry_adb / 1000. / temp_scale);\n    rotateAboutPoint(adiab_line, new THREE.Vector3(0, -params.H_stack, -2 - params.T_surf / temp_scale), new THREE.Vector3(1, 0, 0), rot_angle, false);\n\n}\n\nfunction reset_particle_positions() {\n    var positions = particles.geometry.attributes.position.array;\n    for (var i = 0; i < N_max; i++) {\n        positions[i * 3] = i / N_max * X_max; // x\n        positions[i * 3 + 1] = 0; // y\n        positions[i * 3 + 2] = 0; // z\n        if (params.inversion_layer && (params.H_stack > params.H_inversion)) {\n            T[i] = params.T_stack + params.T_surf - params.Gamma * (params.H_inversion) / 1000. - params.Gamma_inv * (params.H_stack - params.H_inversion) / 1000.; // Temp at this elevation, above inversion layer\n        }\n        else {\n            T[i] = params.T_stack + params.T_surf - params.Gamma * params.H_stack / 1000.;\n        }\n    }\n}\n\nfunction add_particles() {\n    var positions = new Float32Array(N_max * 3);\n    var scales = new Float32Array(N_max);\n    var colors = [];\n    // var geometry = new THREE.Geometry();\n\n    for (var i = 0; i < N_max; i++) {\n        positions[i * 3] = i / N_max * X_max; // x\n        positions[i * 3 + 1] = 0; // y\n        positions[i * 3 + 2] = 0; // z\n        scales[i] = 0.25;\n        v_y[i] = 0;\n        if (params.inversion_layer && (params.H_stack > params.H_inversion)) {\n            T[i] = params.T_stack + params.T_surf - params.Gamma * (params.H_inversion) / 1000. - params.Gamma_inv * (params.H_stack - params.H_inversion) / 1000.; // Temp at this elevation, above inversion layer\n        }\n        else {\n            T[i] = params.T_stack + params.T_surf - params.Gamma * params.H_stack / 1000.;\n        }\n        colors.push(1, 1, 1);\n    }\n    var geometry = new THREE.BufferGeometry();\n    geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));\n    geometry.addAttribute('scale', new THREE.BufferAttribute(scales, 1));\n    geometry.addAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\n\n    var material = new THREE.ShaderMaterial({\n        vertexShader: document.getElementById('vertexshader').textContent,\n        fragmentShader: document.getElementById('fragmentshader').textContent,\n        vertexColors: THREE.VertexColors\n    });\n    particles = new THREE.Points(geometry, material);\n    world_objects.add(particles);\n}\n\nfunction add_gui() {\n    gui.add(params, 'u').min(0).max(10).step(0.01).name('Wind speed at 10m (m/s)').listen();\n    gui.add(params, 'H_stack').min(0.1).max(100).step(0.1).listen().name('Stack Height (m)').onChange(function () {\n        stack.scale.y = params.H_stack;\n        stack.position.y = -params.H_stack / 2; grid.position.y = -params.H_stack; floor.position.y = -params.H_stack;\n        inversion_layer.position.y = params.H_inversion - params.H_stack - y_offset; reset_temp_line(); reset_particle_positions();\n    });\n    // gui.add( params, 'birth_rate').min(100).max(1000).name('Particle Rate (1/s)').listen();\n    gui.add(params, 'D').min(0).max(0.1).step(0.001).name('Diffusivity (m²/s)').listen();\n    gui.add(params, 'Dx').name('Diffusivity downwind').listen();\n\n    if (VR) { var base_layer = gui; }\n    else { var base_layer = gui.addFolder('Temperature effects'); }\n    base_layer.add(params, 'adiab').name('Temperature effects').listen().onChange(function () { vert_axis.visible = params.adiab; horiz_axis.visible = params.adiab; temp_line.visible = params.adiab; });\n    base_layer.add(params, 'Gamma').min(-200).max(200).step(1).name('Env lapse rate (°C/km)').listen().onChange(function () { reset_temp_line(); });\n    base_layer.add(params, 'T_surf').min(0).max(50).step(0.1).name('Surface Temp (°C)').listen().onChange(function () { reset_temp_line(); });\n    base_layer.add(params, 'T_stack').min(-50).max(50).step(0.1).name('Rel Stack Temp (°C)').listen();\n\n    if (VR) { var inv_folder = gui; }\n    else { var inv_folder = gui.addFolder('Inversion Layer'); }\n    inv_folder.add(params, 'inversion_layer').name('Inversion layer').listen().onChange(function () { inversion_layer.visible = params.inversion_layer; reset_temp_line(); });\n    inv_folder.add(params, 'H_inversion').min(0).max(50).step(0.1).name('Height of inv layer (m)').listen().onChange(function () { inversion_layer.position.y = params.H_inversion - params.H_stack; reset_temp_line(); });\n    inv_folder.add(params, 'Gamma_inv').min(-200).max(200).name('Inv lapse rate (°C/km)').listen().onChange(function () { inversion_layer.position.y = params.H_inversion - params.H_stack; reset_temp_line(); });\n\n    if (debug_air_flow) {\n        if (VR) { var turb_folder = gui; }\n        else { var turb_folder = gui.addFolder('Turbulence'); }\n        turb_folder.add(params, 'turbulence').name('Turbulence').listen();\n        turb_folder.add(params, 'I').name('Turbulence intensity').min(0).max(1).step(0.01).listen();\n        turb_folder.add(params, 'omega').name('Eddy length (m)').min(0).max(10).step(0.01).listen();\n    }\n\n    if (VR) { // JUST IN VR MODE\n        // presets = new THREE.Group;\n        //gui.add( presets, 'Presets');\n        gui.add(presets, 'Presets', ['Looping', 'Coning', 'Fanning', 'Lofting', 'Fumigation', 'Trapping']).onChange(function () { set_from_presets(); });\n        //console.log(presets)\n\n    }\n    else { // JUST IN NON-VR MODE\n        if (colour_options) {\n            var colour_folder = gui;\n            colour_folder.add(params, 'colour_by', ['Relative Temp', 'Temp', 'Vertical velocity']).name('Colour By').onChange(function () {\n                if (params.colour_by === 'Relative Temp') { params.cmin = -1; params.cmax = 1; }\n                else if (params.colour_by === 'Temp') { params.cmin = 0; params.cmax = 50; }\n                else if (params.colour_by === 'Vertical velocity') { params.cmin = -2; params.cmax = 2; }\n            });\n            colour_folder.add(params, 'cmin').min(-10).max(10).name('Min colour').onChange(function () { lut.setMin(params.cmin); });\n            colour_folder.add(params, 'cmax').min(-10).max(10).name('Max colour').onChange(function () { lut.setMax(params.cmax); });\n        }\n        gui.add(presets, 'Presets', ['Looping', 'Coning', 'Fanning', 'Lofting', 'Fumigation', 'Trapping']).name('Presets').onChange(function () { set_from_presets(); });\n    }\n}\n\nfunction set_from_presets() {\n    for (i = 0; i < preset_settings.length; i++) {\n        //console.log(presets.Presets)\n        //console.log(preset_settings[i].Presets)\n        if (presets.Presets === preset_settings[i].Presets) {\n            var keys = Object.keys(preset_settings[i]);\n            var values = Object.values(preset_settings[i])\n            for (j = 0; j < keys.length; j++) {\n                params[keys[j]] = values[j];\n            }\n\n            reset_particle_positions();\n            // just in case\n            stack.scale.y = params.H_stack; stack.position.y = -params.H_stack / 2.; floor.position.y = -params.H_stack; grid.position.y = -params.H_stack + 0.01; inversion_layer.position.y = params.H_inversion - params.H_stack;\n            inversion_layer.visible = params.inversion_layer;\n            vert_axis.visible = params.adiab; horiz_axis.visible = params.adiab; temp_line.visible = params.adiab;\n            reset_temp_line();\n        }\n    }\n}\n\nfunction add_renderer() {\n    renderer = new THREE.WebGLRenderer({ antialias: true });\n    renderer.setPixelRatio(window.devicePixelRatio);\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    container.appendChild(renderer.domElement);\n    if (VR) {\n        renderer.xr.enabled = true;\n        container.appendChild(three_examples_jsm_webxr_VRButton_js__WEBPACK_IMPORTED_MODULE_0__.VRButton.createButton(renderer));\n\n\n        // var dolly = new THREE.Group();\n        // scene.add(dolly);\n        // renderer.vr.setPoseTarget(dolly);\n        // dolly.add(camera);\n        // THREE.VRController.verbosity = 1\n    }\n    else {\n        controls = new THREE.OrbitControls(camera, renderer.domElement);\n        controls.target.set(2, 0, 0);\n        controls.update();\n    }\n\n};\nfunction add_left_oculus_model(controller) {\n    new THREE.MTLLoader()\n        .setPath(root_dir + 'resources/oculus/')\n        .load('oculus-touch-controller-left.mtl', function (materials) {\n            materials.preload();\n            new THREE.OBJLoader()\n                .setMaterials(materials)\n                .setPath(root_dir + 'resources/oculus/')\n                .load('oculus-touch-controller-left.obj', function (object) {\n                    object.castShadow = true;\n                    object.receiveShadow = true;\n                    // Pause label\n                    var font_loader = new THREE.FontLoader();\n                    font_loader.load(root_dir + 'node_modules/three/examples/fonts/helvetiker_bold.typeface.json', function (font) {\n                        var fontsize = 0.005;\n                        controller.add(object);\n                        var geometry = new THREE.TextBufferGeometry(\"Pick\", { font: font, size: fontsize, height: fontsize / 5. });\n                        var material = new THREE.MeshPhongMaterial({ color: 0xdddddd });\n                        var move_label = new THREE.Mesh(geometry, material);\n                        move_label.rotation.x = -1. * Math.PI / 4.;\n                        move_label.rotation.y = Math.PI;\n                        move_label.position.y = -0.035 - fontsize;\n                        move_label.position.x = 0.018;\n                        move_label.position.z = 0.045;\n                        object.add(move_label);\n                    });\n                });\n        });\n}\n\nfunction add_right_oculus_model(controller) {\n    new THREE.MTLLoader()\n        .setPath(root_dir + 'resources/oculus/')\n        .load('oculus-touch-controller-right.mtl', function (materials) {\n            materials.preload();\n            new THREE.OBJLoader()\n                .setMaterials(materials)\n                .setPath(root_dir + 'resources/oculus/')\n                .load('oculus-touch-controller-right.obj', function (object) {\n                    object.castShadow = true;\n                    object.receiveShadow = true;\n\n                    // Pause label\n                    var font_loader = new THREE.FontLoader();\n                    font_loader.load(root_dir + 'node_modules/three/examples/fonts/helvetiker_bold.typeface.json', function (font) {\n                        var fontsize = 0.005;\n                        controller.add(object);\n                        // scene.add( object );\n\n                        var geometry = new THREE.TextBufferGeometry(\"Pick\", { font: font, size: fontsize, height: fontsize / 5. });\n                        var material = new THREE.MeshPhongMaterial({ color: 0xdddddd });\n                        var move_label = new THREE.Mesh(geometry, material);\n                        move_label.rotation.x = -1. * Math.PI / 4.;\n                        move_label.rotation.y = Math.PI;\n                        move_label.position.y = -0.035 - fontsize;\n                        move_label.position.x = 0.0;\n                        move_label.position.z = 0.045;\n                        object.add(move_label);\n                    });\n                });\n        });\n}\n\nfunction add_controllers() {\n    controller1 = new THREE.Object3D;\n    controller2 = new THREE.Object3D;\n\n    if (vive) {\n        var loader = new THREE.OBJLoader();\n        // loader.setPath( 'http://benjymarks.com/nddem/visualise/resources/vive/' );\n        loader.load('resources/vr_controller_vive_1_5.obj', function (object) {\n            var loader = new THREE.TextureLoader();\n            // loader.setPath( 'http://benjymarks.com/nddem/visualise/resources/vive/' );\n            var controller = object.children[0];\n            controller.material.map = loader.load('resources/onepointfive_texture.png');\n            controller.material.specularMap = loader.load('resources/onepointfive_spec.png');\n            controller1.add(controller.clone());\n            controller2.add(controller.clone());\n        });\n    }\n\n    window.addEventListener('vr controller connected', function (event) {\n        //  Here it is, your VR controller instance.\n        //  It’s really a THREE.Object3D so you can just add it to your scene:\n        var controller = event.detail\n        if (controller.gamepad.hand === 'left') {\n            controller.add(controller1);\n            if (controller.gamepad.id === 'Oculus Touch (Left)') { add_left_oculus_model(controller); }\n        }\n        else if (controller.gamepad.hand === 'right') {\n            controller.add(controller2);\n            if (controller.gamepad.id === 'Oculus Touch (Right)') { add_right_oculus_model(controller); }\n        }\n        scene.add(controller);\n        controller.standingMatrix = renderer.vr.getStandingMatrix();\n        controller.head = window.camera;\n        var guiInputHelper = dat.GUIVR.addInputObject(controller); //  Allow this controller to interact with DAT GUI.\n        scene.add(guiInputHelper);\n\n        controller.addEventListener('thumbstick axes changed', function (event) {\n            up = -event.axes[1]; // distance up on the thumbstick\n            left = event.axes[0];\n            event.target.getWorldDirection(direction); // controller\n            //console.log(direction);\n        });\n\n        // controller.addEventListener( 'thumbstick axes changed', function( event ) {\n        //  var up = - event.axes[1];\n        // } );\n        //THREE.VRController.verbosity = 1;\n        //THREE.VRController.inspect()\n    });\n}\n\nfunction init() {\n    container = document.getElementById('container');\n    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);\n    scene = new THREE.Scene();\n    scene.add(world_objects);\n\n    var ambientLight = new THREE.AmbientLight(0xFFFFFF);\n    world_objects.add(ambientLight);\n\n    var light = new THREE.PointLight(0xffffff, 1);\n    light.position.set(- 2, 2, 5);\n    world_objects.add(light);\n\n    grid = new THREE.GridHelper(100, 100, 0x000000, 0x000000);\n    // grid.material.depthTest = false;\n    // grid.rotation.x = Math.PI/2.;\n    grid.position.y = -params.H_stack + 0.01;\n    world_objects.add(grid);\n\n    var geometry = new THREE.PlaneGeometry();//R, R, params.H_stack, 32 );\n    var material = new THREE.MeshStandardMaterial({ color: 0xeeeeee, side: THREE.DoubleSide });\n    floor = new THREE.Mesh(geometry, material);\n\n    floor.rotation.x = Math.PI / 2.;\n    floor.position.y = -params.H_stack;\n    floor.scale.set(2 * X_max, 2 * X_max, 1);\n    world_objects.add(floor);\n\n    var geometry = new THREE.PlaneGeometry();//R, R, params.H_stack, 32 );\n    var material = new THREE.MeshStandardMaterial({ color: 0xeeeeee, side: THREE.DoubleSide, opacity: 0.2, transparent: true });\n    inversion_layer = new THREE.Mesh(geometry, material);\n\n    inversion_layer.rotation.x = Math.PI / 2.;\n    inversion_layer.position.y = params.H_inversion - params.H_stack;\n    inversion_layer.scale.set(2 * X_max, 2 * X_max, 1);\n    world_objects.add(inversion_layer);\n    inversion_layer.visible = params.inversion_layer;\n\n    if (!VR) { window.addEventListener('resize', onWindowResize, false); }\n\n    var geometry = new THREE.CylinderGeometry(R, R, 1, 32);\n    var material = new THREE.MeshStandardMaterial({ color: 0xe72564 });\n    stack = new THREE.Mesh(geometry, material);\n    stack.scale.y = params.H_stack;\n    stack.position.y = -params.H_stack / 2.;\n    world_objects.add(stack);\n    world_objects.add(particles);\n\n\n    if (VR) { // get good initial state\n        world_objects.position.x = -1;\n        world_objects.position.y = 2;\n        world_objects.position.z = 1;\n    }\n    else { camera.position.set(2, 1, 3); }\n\n}\n\nfunction moveParticles(dt) {\n    var positions = particles.geometry.attributes.position.array;\n    var colors = particles.geometry.attributes.color.array;\n    var scales = particles.geometry.attributes.scale.array;\n    var delta = Math.sqrt(2. * params.D * dt);\n\n    if (params.Dx) {\n        for (var i = 0; i < N_max; i++) {\n            positions[i * 3] += (Math.random() - 0.5) * delta;\n        }\n    }\n    for (var i = 0; i < N_max; i++) {\n        var t = clock.getElapsedTime();\n        positions[i * 3 + 2] += (Math.random() - 0.5) * delta;\n        var dy = (Math.random() - 0.5) * delta;\n        if (params.wind_type === 'Uniform') { u = params.u; }\n        else if (params.wind_type === 'Boundary Layer') {\n            u = params.u * Math.pow(Math.abs(params.H_stack + positions[i * 3 + 1]) / 10., 0.143); // u = u_{10m}(z)*(z/10)^0.143\n        }\n        if (params.turbulence) {\n            positions[i * 3] += u * dt * (1. + params.I * Math.cos((positions[i * 3] - u * t) / params.omega) * Math.sin(positions[i * 3 + 1] / params.omega));\n            dy -= u * dt * params.I * Math.sin((positions[i * 3] - u * t) / params.omega) * Math.cos(positions[i * 3 + 1] / params.omega);\n        }\n        else {\n            positions[i * 3] += u * dt;\n        }\n        positions[i * 3 + 1] += dy;\n        T[i] += -Gamma_dry_adb * dy / 1000.; // particle cools adiabatically with adiabatic lapse rate\n\n        if (positions[i * 3] > X_max) { // reset particle\n            positions[i * 3] = 0;\n            positions[i * 3 + 1] = 0;\n            positions[i * 3 + 2] = 0;\n            v_y[i] = 0;\n            if (params.inversion_layer && (params.H_stack > params.H_inversion)) {\n                T[i] = params.T_stack + params.T_surf - params.Gamma * (params.H_inversion) / 1000. - params.Gamma_inv * (params.H_stack - params.H_inversion) / 1000.; // Temp at this elevation, above inversion layer\n            }\n            else {\n                T[i] = params.T_stack + params.T_surf - params.Gamma * params.H_stack / 1000.;\n            }\n        }\n\n    }\n    if (params.adiab) {\n        for (var i = 0; i < N_max; i++) {\n            if (positions[i * 3 + 1] + params.H_stack > params.H_inversion && params.inversion_layer) {\n                var T_elevation = params.T_surf - params.Gamma * (params.H_inversion) / 1000. - params.Gamma_inv * (positions[i * 3 + 1] + params.H_stack - params.H_inversion) / 1000.; // Temp at this elevation, above inversion layer\n            }\n            else {\n                var T_elevation = params.T_surf - params.Gamma * (positions[i * 3 + 1] + params.H_stack) / 1000.; // Temp at this elevation\n            }\n            var a_y = g * ((T[i] + 273.15) / (T_elevation + 273.15) - 1.);\n            a_y -= 1e0 * Math.pow(v_y[i], 2) * Math.sign(v_y[i]);\n\n            v_y[i] += a_y * dt;\n            var dy = v_y[i] * dt;\n            positions[i * 3 + 1] += dy;\n            T[i] += -Gamma_dry_adb * dy / 1000.; // particle cools adiabatically with adiabatic lapse rate\n            if (positions[i * 3 + 1] < -params.H_stack) { // bounce off floor\n                positions[i * 3 + 1] -= 1.5 * (params.H_stack + positions[i * 3 + 1]); // put back in - little bit of dissipation to look nice\n                T[i] = params.T_surf;//-params.Gamma*( positions[ i*3 + 1 ]+params.H_stack )/1000.;\n                v_y[i] = 0;\n            }\n            if (params.colour_by === 'Relative Temp') { c = lut.getColor(T[i] - T_elevation); }\n            else if (params.colour_by === 'Temp') { c = lut.getColor(T[i]); }\n            else if (params.colour_by === 'Vertical velocity') { c = lut.getColor(v_y[i]); }\n\n            colors[i * 3] = c.r; colors[i * 3 + 1] = c.g; colors[i * 3 + 2] = c.b;\n\n            // var P = 1e5*Math.exp(-positions[ i*3 + 1]/7000.);\n            // scales[i] = Math.pow(nR*T[i]/P,0.33333);  // V = nRT/P, d \\propto V**0.33;\n            // scales[i] = nR*T[i]/P;  // V = nRT/P - looks a bit better\n\n        }\n    }\n\n    particles.geometry.attributes.position.needsUpdate = true;\n    // particles.geometry.attributes.scale.needsUpdate = true;\n    particles.geometry.attributes.color.needsUpdate = true;\n}\n\nfunction onWindowResize() {\n    camera.aspect = window.innerWidth / window.innerHeight;\n    // camera.lookAt(2,0,0);\n    camera.updateProjectionMatrix();\n    renderer.setSize(window.innerWidth, window.innerHeight);\n\n}\n\nfunction animate() {\n    THREE.VRController.update();\n    requestAnimationFrame(animate);\n    // render();\n    renderer.setAnimationLoop(render);\n}\n\nfunction render() {\n    var deltaTime = clock.getDelta();\n    world_objects.position.x += fly_speed * up * deltaTime * direction.x;\n    world_objects.position.y += fly_speed * up * deltaTime * direction.y;\n    world_objects.position.z += fly_speed * up * deltaTime * direction.z;\n\n    // NOTE: need to do something clever here, don't have the brain power tonight\n    // var left_direction = THREE.Vector3.crossVectors(direction,;\n    // world_objects.position.x += fly_speed*left*deltaTime*left_direction.x;\n    // world_objects.position.y += fly_speed*left*deltaTime*left_direction.y;\n    // world_objects.position.z += fly_speed*left*deltaTime*left_direction.z;\n\n    moveParticles(deltaTime);\n    renderer.render(scene, camera);\n}\n\n\n//# sourceURL=webpack://dispersion-vr/./js/index.js?");

/***/ }),

/***/ "./node_modules/three/examples/jsm/webxr/VRButton.js":
/*!***********************************************************!*\
  !*** ./node_modules/three/examples/jsm/webxr/VRButton.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VRButton\": () => (/* binding */ VRButton)\n/* harmony export */ });\nclass VRButton {\n\n\tstatic createButton( renderer, options ) {\n\n\t\tif ( options ) {\n\n\t\t\tconsole.error( 'THREE.VRButton: The \"options\" parameter has been removed. Please set the reference space type via renderer.xr.setReferenceSpaceType() instead.' );\n\n\t\t}\n\n\t\tconst button = document.createElement( 'button' );\n\n\t\tfunction showEnterVR( /*device*/ ) {\n\n\t\t\tlet currentSession = null;\n\n\t\t\tasync function onSessionStarted( session ) {\n\n\t\t\t\tsession.addEventListener( 'end', onSessionEnded );\n\n\t\t\t\tawait renderer.xr.setSession( session );\n\t\t\t\tbutton.textContent = 'EXIT VR';\n\n\t\t\t\tcurrentSession = session;\n\n\t\t\t}\n\n\t\t\tfunction onSessionEnded( /*event*/ ) {\n\n\t\t\t\tcurrentSession.removeEventListener( 'end', onSessionEnded );\n\n\t\t\t\tbutton.textContent = 'ENTER VR';\n\n\t\t\t\tcurrentSession = null;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tbutton.style.display = '';\n\n\t\t\tbutton.style.cursor = 'pointer';\n\t\t\tbutton.style.left = 'calc(50% - 50px)';\n\t\t\tbutton.style.width = '100px';\n\n\t\t\tbutton.textContent = 'ENTER VR';\n\n\t\t\tbutton.onmouseenter = function () {\n\n\t\t\t\tbutton.style.opacity = '1.0';\n\n\t\t\t};\n\n\t\t\tbutton.onmouseleave = function () {\n\n\t\t\t\tbutton.style.opacity = '0.5';\n\n\t\t\t};\n\n\t\t\tbutton.onclick = function () {\n\n\t\t\t\tif ( currentSession === null ) {\n\n\t\t\t\t\t// WebXR's requestReferenceSpace only works if the corresponding feature\n\t\t\t\t\t// was requested at session creation time. For simplicity, just ask for\n\t\t\t\t\t// the interesting ones as optional features, but be aware that the\n\t\t\t\t\t// requestReferenceSpace call will fail if it turns out to be unavailable.\n\t\t\t\t\t// ('local' is always available for immersive sessions and doesn't need to\n\t\t\t\t\t// be requested separately.)\n\n\t\t\t\t\tconst sessionInit = { optionalFeatures: [ 'local-floor', 'bounded-floor', 'hand-tracking', 'layers' ] };\n\t\t\t\t\tnavigator.xr.requestSession( 'immersive-vr', sessionInit ).then( onSessionStarted );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentSession.end();\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\tfunction disableButton() {\n\n\t\t\tbutton.style.display = '';\n\n\t\t\tbutton.style.cursor = 'auto';\n\t\t\tbutton.style.left = 'calc(50% - 75px)';\n\t\t\tbutton.style.width = '150px';\n\n\t\t\tbutton.onmouseenter = null;\n\t\t\tbutton.onmouseleave = null;\n\n\t\t\tbutton.onclick = null;\n\n\t\t}\n\n\t\tfunction showWebXRNotFound() {\n\n\t\t\tdisableButton();\n\n\t\t\tbutton.textContent = 'VR NOT SUPPORTED';\n\n\t\t}\n\n\t\tfunction showVRNotAllowed( exception ) {\n\n\t\t\tdisableButton();\n\n\t\t\tconsole.warn( 'Exception when trying to call xr.isSessionSupported', exception );\n\n\t\t\tbutton.textContent = 'VR NOT ALLOWED';\n\n\t\t}\n\n\t\tfunction stylizeElement( element ) {\n\n\t\t\telement.style.position = 'absolute';\n\t\t\telement.style.bottom = '20px';\n\t\t\telement.style.padding = '12px 6px';\n\t\t\telement.style.border = '1px solid #fff';\n\t\t\telement.style.borderRadius = '4px';\n\t\t\telement.style.background = 'rgba(0,0,0,0.1)';\n\t\t\telement.style.color = '#fff';\n\t\t\telement.style.font = 'normal 13px sans-serif';\n\t\t\telement.style.textAlign = 'center';\n\t\t\telement.style.opacity = '0.5';\n\t\t\telement.style.outline = 'none';\n\t\t\telement.style.zIndex = '999';\n\n\t\t}\n\n\t\tif ( 'xr' in navigator ) {\n\n\t\t\tbutton.id = 'VRButton';\n\t\t\tbutton.style.display = 'none';\n\n\t\t\tstylizeElement( button );\n\n\t\t\tnavigator.xr.isSessionSupported( 'immersive-vr' ).then( function ( supported ) {\n\n\t\t\t\tsupported ? showEnterVR() : showWebXRNotFound();\n\n\t\t\t\tif ( supported && VRButton.xrSessionIsGranted ) {\n\n\t\t\t\t\tbutton.click();\n\n\t\t\t\t}\n\n\t\t\t} ).catch( showVRNotAllowed );\n\n\t\t\treturn button;\n\n\t\t} else {\n\n\t\t\tconst message = document.createElement( 'a' );\n\n\t\t\tif ( window.isSecureContext === false ) {\n\n\t\t\t\tmessage.href = document.location.href.replace( /^http:/, 'https:' );\n\t\t\t\tmessage.innerHTML = 'WEBXR NEEDS HTTPS'; // TODO Improve message\n\n\t\t\t} else {\n\n\t\t\t\tmessage.href = 'https://immersiveweb.dev/';\n\t\t\t\tmessage.innerHTML = 'WEBXR NOT AVAILABLE';\n\n\t\t\t}\n\n\t\t\tmessage.style.left = 'calc(50% - 90px)';\n\t\t\tmessage.style.width = '180px';\n\t\t\tmessage.style.textDecoration = 'none';\n\n\t\t\tstylizeElement( message );\n\n\t\t\treturn message;\n\n\t\t}\n\n\t}\n\n\tstatic xrSessionIsGranted = false;\n\n\tstatic registerSessionGrantedListener() {\n\n\t\tif ( 'xr' in navigator ) {\n\n\t\t\t// WebXRViewer (based on Firefox) has a bug where addEventListener\n\t\t\t// throws a silent exception and aborts execution entirely.\n\t\t\tif ( /WebXRViewer\\//i.test( navigator.userAgent ) ) return;\n\n\t\t\tnavigator.xr.addEventListener( 'sessiongranted', () => {\n\n\t\t\t\tVRButton.xrSessionIsGranted = true;\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\nVRButton.registerSessionGrantedListener();\n\n\n\n\n//# sourceURL=webpack://dispersion-vr/./node_modules/three/examples/jsm/webxr/VRButton.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./js/index.js");
/******/ 	
/******/ })()
;